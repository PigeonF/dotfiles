diff --git a/src/parser-includes.ts b/src/parser-includes.ts
index dfa3a2f4b8706546..9c0c62a4b5789897 100644
--- a/src/parser-includes.ts
+++ b/src/parser-includes.ts
@@ -61,6 +61,8 @@ export class ParserIncludes {
         await Promise.all(promises);
 
         for (const value of include) {
+            const inputs = value["inputs"] || {};
+
             if (value["rules"]) {
                 const include_rules = value["rules"];
                 const rulesResult = Utils.getRulesResult({cwd, rules: include_rules, variables: opts.variables});
@@ -71,13 +73,13 @@ export class ParserIncludes {
             if (value["local"]) {
                 const files = await globby([value["local"].replace(/^\//, ""), ...excludedGlobs], {dot: true, cwd});
                 for (const localFile of files) {
-                    const content = await Parser.loadYaml(`${cwd}/${localFile}`);
-                    excludedGlobs.push(`!${localFile}`);
+                    const content = await Parser.loadYaml(`${cwd}/${localFile}`, inputs);
+                    // excludedGlobs.push(`!${localFile}`);
                     includeDatas = includeDatas.concat(await this.init(content, depth, opts));
                 }
             } else if (value["project"]) {
                 for (const fileValue of Array.isArray(value["file"]) ? value["file"] : [value["file"]]) {
-                    const fileDoc = await Parser.loadYaml(`${cwd}/${stateDir}/includes/${gitData.remote.host}/${value["project"]}/${value["ref"] || "HEAD"}/${fileValue}`);
+                    const fileDoc = await Parser.loadYaml(`${cwd}/${stateDir}/includes/${gitData.remote.host}/${value["project"]}/${value["ref"] || "HEAD"}/${fileValue}`, inputs);
 
                     // Expand local includes inside a "project"-like include
                     fileDoc["include"] = this.expandInclude(fileDoc["include"], opts.variables);
@@ -95,11 +97,11 @@ export class ParserIncludes {
             } else if (value["template"]) {
                 const {project, ref, file, domain} = this.covertTemplateToProjectFile(value["template"]);
                 const fsUrl = Utils.fsUrl(`https://${domain}/${project}/-/raw/${ref}/${file}`);
-                const fileDoc = await Parser.loadYaml(`${cwd}/${stateDir}/includes/${fsUrl}`);
+                const fileDoc = await Parser.loadYaml(`${cwd}/${stateDir}/includes/${fsUrl}`, inputs);
                 includeDatas = includeDatas.concat(await this.init(fileDoc, depth, opts));
             } else if (value["remote"]) {
                 const fsUrl = Utils.fsUrl(value["remote"]);
-                const fileDoc = await Parser.loadYaml(`${cwd}/${stateDir}/includes/${fsUrl}`);
+                const fileDoc = await Parser.loadYaml(`${cwd}/${stateDir}/includes/${fsUrl}`, inputs);
                 includeDatas = includeDatas.concat(await this.init(fileDoc, depth, opts));
             } else {
                 throw new AssertionError({message: `Didn't understand include ${JSON.stringify(value)}`});
diff --git a/src/parser.ts b/src/parser.ts
index d41c5caac132ebe8..4e48fe0395c52a6c 100644
--- a/src/parser.ts
+++ b/src/parser.ts
@@ -187,14 +187,41 @@ export class Parser {
         });
     }
 
-    static async loadYaml (filePath: string): Promise<any> {
+    static async loadYaml (filePath: string, inputs: {[key: string]: boolean | string | number} = {}): Promise<any> {
         const ymlPath = `${filePath}`;
         if (!fs.existsSync(ymlPath)) {
             return {};
         }
 
+        const referenceType = new yaml.Type("!reference", {
+            kind: "sequence",
+            construct: function (data) {
+                return {referenceData: data};
+            },
+        });
+        const schema = yaml.DEFAULT_SCHEMA.extend([referenceType]);
         const fileContent = await fs.readFile(`${filePath}`, "utf8");
-        const fileSplit = fileContent.split(/\r?\n/g);
+        const documents = fileContent.split(/(?:\r?\n|^)---\r?\n/g);
+        const firstYaml = yaml.load(documents[0], {schema}) || {};
+        // If file begins with `---`, we have one empty document that we disregard
+        if (Object.keys(firstYaml).length === 0) {
+            documents.splice(0, 1);
+        }
+        assert(documents.length <= 2, "GitLab CI file can at most have 2 documents");
+
+        const preamble: any = documents.length == 1 ? {"spec": {"inputs": {}}} : yaml.load(documents[0]);
+        let document = documents[documents.length == 1 ? 0 : 1];
+        assert(preamble["spec"] && preamble["spec"]["inputs"],
+            "Multi-document GitLab CI file requires spec:inputs in the first document");
+        const inputSpec: {[key: string]: null | {[key: string]: string | boolean | number}} = preamble["spec"]["inputs"];
+        for (const input in inputSpec) {
+            const config = inputSpec[input] || {};
+            const value = inputs[input] || config["default"] || null;
+            assert(value !== null, `Missing value for ${input} in ${filePath}`);
+            document = document.replaceAll(`$[[ inputs.${input} ]]`, value.toString());
+        }
+
+        const fileSplit = document.split(/\r?\n/g);
         const fileSplitClone = fileSplit.slice();
 
         let interactiveMatch = null;
@@ -234,13 +261,6 @@ export class Parser {
             index++;
         }
 
-        const referenceType = new yaml.Type("!reference", {
-            kind: "sequence",
-            construct: function (data) {
-                return {referenceData: data};
-            },
-        });
-        const schema = yaml.DEFAULT_SCHEMA.extend([referenceType]);
         return yaml.load(fileSplitClone.join("\n"), {schema}) || {};
     }
 
diff --git a/tests/test-cases/include-local-inputs/.gitlab-ci.yml b/tests/test-cases/include-local-inputs/.gitlab-ci.yml
new file mode 100644
index 0000000000000000..e3d7bf78aa33c9df
--- /dev/null
+++ b/tests/test-cases/include-local-inputs/.gitlab-ci.yml
@@ -0,0 +1,13 @@
+# Some comments
+
+# Some more comments
+---
+include:
+  - local: template.yml
+    inputs:
+      name: hello-world
+  - local: template.yml
+    inputs:
+      name: hello-gcl
+      greeting: GCL
+  - local: template-with-defaults.yml
diff --git a/tests/test-cases/include-local-inputs/integration.include-local-inputs.test.ts b/tests/test-cases/include-local-inputs/integration.include-local-inputs.test.ts
new file mode 100644
index 0000000000000000..799ab0b279f33f83
--- /dev/null
+++ b/tests/test-cases/include-local-inputs/integration.include-local-inputs.test.ts
@@ -0,0 +1,56 @@
+import {WriteStreamsMock} from "../../../src/write-streams";
+import {handler} from "../../../src/handler";
+import chalk from "chalk";
+import {initSpawnSpy} from "../../mocks/utils.mock";
+import {WhenStatics} from "../../mocks/when-statics";
+
+beforeAll(() => {
+    initSpawnSpy(WhenStatics.all);
+});
+
+test("include-local-inputs <hello-world>", async () => {
+    const writeStreams = new WriteStreamsMock();
+    await handler({
+        cwd: "tests/test-cases/include-local-inputs",
+        file: ".gitlab-ci.yml",
+        job: ["hello-world"],
+    }, writeStreams);
+
+    const expected = [
+        chalk`{blueBright hello-world          } {greenBright >} Hello, World`,
+        chalk`{blueBright hello-world          } {greenBright >} How are you World?`,
+    ];
+
+    expect(writeStreams.stdoutLines).toEqual(expect.arrayContaining(expected));
+});
+
+test("include-local-inputs <hello-gcl>", async () => {
+    const writeStreams = new WriteStreamsMock();
+    await handler({
+        cwd: "tests/test-cases/include-local-inputs",
+        file: ".gitlab-ci.yml",
+        job: ["hello-gcl"],
+    }, writeStreams);
+
+    const expected = [
+        chalk`{blueBright hello-gcl            } {greenBright >} Hello, GCL`,
+        chalk`{blueBright hello-gcl            } {greenBright >} How are you GCL?`,
+    ];
+
+    expect(writeStreams.stdoutLines).toEqual(expect.arrayContaining(expected));
+});
+
+test("include-local-inputs <job-with-default-name>", async () => {
+    const writeStreams = new WriteStreamsMock();
+    await handler({
+        cwd: "tests/test-cases/include-local-inputs",
+        file: ".gitlab-ci.yml",
+        job: ["job-with-default-name"],
+    }, writeStreams);
+
+    const expected = [
+        chalk`{blueBright job-with-default-name} {greenBright >} Hello, World`,
+    ];
+
+    expect(writeStreams.stdoutLines).toEqual(expect.arrayContaining(expected));
+});
diff --git a/tests/test-cases/include-local-inputs/template-with-defaults.yml b/tests/test-cases/include-local-inputs/template-with-defaults.yml
new file mode 100644
index 0000000000000000..fd288af6f0240d85
--- /dev/null
+++ b/tests/test-cases/include-local-inputs/template-with-defaults.yml
@@ -0,0 +1,9 @@
+spec:
+  inputs:
+    name:
+      default: job-with-default-name
+---
+"$[[ inputs.name ]]":
+  stage: build
+  script:
+    - echo "Hello, World"
diff --git a/tests/test-cases/include-local-inputs/template.yml b/tests/test-cases/include-local-inputs/template.yml
new file mode 100644
index 0000000000000000..e2cfd3c04a10460f
--- /dev/null
+++ b/tests/test-cases/include-local-inputs/template.yml
@@ -0,0 +1,11 @@
+spec:
+  inputs:
+    name:
+    greeting:
+      default: World
+---
+"$[[ inputs.name ]]":
+  stage: build
+  script:
+    - echo "Hello, $[[ inputs.greeting ]]"
+    - echo "How are you $[[ inputs.greeting ]]?"
