diff --git a/src/parser.ts b/src/parser.ts
index 3200068bba2e6b56..4360717caf90fc66 100644
--- a/src/parser.ts
+++ b/src/parser.ts
@@ -19,7 +19,12 @@ import {WriteStreams} from "./write-streams";
 import {init as initPredefinedVariables} from "./predefined-variables";
 
 const MAX_FUNCTIONS = 3;
-const INCLUDE_INPUTS_SUPPORTED_TYPES = ["string", "boolean", "number"];
+const INCLUDE_INPUTS_SUPPORTED_TYPES: Record<string, (_: any) => boolean> = {
+    "array": (v: any) => Array.isArray(v),
+    "string": (v: any) => typeof v == "string",
+    "boolean": (v: any) => typeof v == "boolean",
+    "number": (v: any) => typeof v == "number",
+};
 
 export class Parser {
 
@@ -290,12 +295,51 @@ export class Parser {
         if (isGitlabSpecFile(fileData[0])) {
             const inputsSpecification: any = fileData[0];
             const uninterpolatedConfigurations: any = fileData[1];
+            const configFilePath = path.relative(process.cwd(), filePath);
+
+            const interpolateArray = (object: any) => {
+                Object.entries(object).forEach(([name, value]) => {
+                    if (typeof value == "object") {
+                        interpolateArray(value);
+                        return;
+                    }
+                    if (typeof value != "string") {
+                        return;
+                    }
+
+                    const match = value.match(/^\$\[\[\s*inputs.(?<interpolationKey>[\w-]+)\s*\|?\s*(?<interpolationFunctions>.*?)\s*\]\]$/);
+                    if (match == null || match.groups == null) {
+                        return;
+                    }
+                    const interpolationKey = match.groups.interpolationKey;
+                    const interpolationFunctions = match.groups.interpolationFunctions;
+                    const context = {
+                        interpolationKey,
+                        interpolationFunctions,
+                        inputsSpecification,
+                        configFilePath,
+                        ...ctx,
+                    };
+
+                    validateInterpolationKey(context);
+                    const type = inputsSpecification.spec.inputs[interpolationKey]?.type || "string";
+                    if (type != "array") {
+                        return;
+                    }
+                    validateInterpolationFunctions(context);
+                    const inputValue = getInputValue(context);
+                    validateInput(inputValue, context);
+
+                    object[name] = inputValue;
+                });
+            };
+
+            // Handle arrays first, since we do not want to stringify them when they are a standalone value
+            interpolateArray(uninterpolatedConfigurations);
 
             const interpolatedConfigurations = JSON.stringify(uninterpolatedConfigurations)
-                .replace(
-                    /\$\[\[\s*inputs.(?<interpolationKey>[\w-]+)\s*\|?\s*(?<interpolationFunctions>.*?)\s*\]\]/g // regexr.com/7sh15
+                .replace(/\$\[\[\s*inputs.(?<interpolationKey>[\w-]+)\s*\|?\s*(?<interpolationFunctions>.*?)\s*\]\]/g // regexr.com/7sh15
                     , (_: string, interpolationKey: string, interpolationFunctions: string) => {
-                        const configFilePath = path.relative(process.cwd(), filePath);
                         const context = {
                             interpolationKey,
                             interpolationFunctions,
@@ -310,6 +354,10 @@ export class Parser {
                         validateInput(inputValue, context);
 
                         const jsonValue = JSON.stringify(inputValue);
+                        // Array might contain strings, which have to be escaped.
+                        if (Array.isArray(inputValue)) {
+                            return JSON.stringify(jsonValue).slice(1, -1);
+                        }
                         // Unquote string if necessary
                         if (typeof(jsonValue) == "string" && jsonValue.startsWith("\"") && jsonValue.endsWith("\"")) {
                             return jsonValue.slice(1, -1);
@@ -357,9 +405,10 @@ function validateInput (inputValue: any, ctx: any): any {
     }
 
     const type = inputsSpecification.spec.inputs[interpolationKey]?.type || "string";
-    assert(INCLUDE_INPUTS_SUPPORTED_TYPES.includes(type),
+    assert(type in INCLUDE_INPUTS_SUPPORTED_TYPES,
         chalk`This GitLab CI configuration is invalid: \`{blueBright ${configFilePath}}\`: header:spec:inputs:{blueBright ${interpolationKey}} input type unknown value: {blueBright ${type}}.`);
-    assert(typeof inputValue == type,
+    const validator = INCLUDE_INPUTS_SUPPORTED_TYPES[type];
+    assert(validator(inputValue),
         chalk`This GitLab CI configuration is invalid: \`{blueBright ${configFilePath}}\`: \`{blueBright ${interpolationKey}}\` input: provided value is not a {blueBright ${type}}.`);
 
     const regex = inputsSpecification.spec.inputs[interpolationKey]?.regex;
diff --git a/tests/test-cases/include-inputs/input-templates/array/.gitlab-ci-input-template.yml b/tests/test-cases/include-inputs/input-templates/array/.gitlab-ci-input-template.yml
new file mode 100644
index 0000000000000000..a5d1717ff15335dd
--- /dev/null
+++ b/tests/test-cases/include-inputs/input-templates/array/.gitlab-ci-input-template.yml
@@ -0,0 +1,14 @@
+---
+spec:
+  inputs:
+    echo:
+      type: array
+    needs:
+      type: array
+    rules:
+      type: array
+---
+test_job:
+  needs: $[[ inputs.needs ]]
+  rules: $[[ inputs.rules ]]
+  script: echo '$[[ inputs.echo ]]'
diff --git a/tests/test-cases/include-inputs/input-templates/array/.gitlab-ci.yml b/tests/test-cases/include-inputs/input-templates/array/.gitlab-ci.yml
new file mode 100644
index 0000000000000000..938e72f4c50a9877
--- /dev/null
+++ b/tests/test-cases/include-inputs/input-templates/array/.gitlab-ci.yml
@@ -0,0 +1,18 @@
+---
+include:
+  - local: "/.gitlab-ci-input-template.yml"
+    inputs:
+      needs:
+        - build
+      rules:
+        - if: $RUN_MANUAL
+          when: manual
+      echo:
+        - test
+        - array
+
+build:
+  script: ls
+
+stages:
+  - test
diff --git a/tests/test-cases/include-inputs/integration.include-inputs.test.ts b/tests/test-cases/include-inputs/integration.include-inputs.test.ts
index 7b27e97cfe7ffffd..349c1bde14355e7e 100644
--- a/tests/test-cases/include-inputs/integration.include-inputs.test.ts
+++ b/tests/test-cases/include-inputs/integration.include-inputs.test.ts
@@ -256,3 +256,37 @@ scan-website:
 
     expect(writeStreams.stdoutLines[0]).toEqual(expected);
 });
+
+test("include-inputs allows array inputs", async () => {
+    const writeStreams = new WriteStreamsMock();
+    await handler({
+        cwd: "tests/test-cases/include-inputs/input-templates/array",
+        preview: true,
+    }, writeStreams);
+
+    // TODO(PigeonF): Does not match GitLab output exactly: gitlab
+    // stringification indents list elements by one space.
+    //
+    // I.e. `echo '["test", "array"]'` instead of `echo '["test","array"]'`.
+    //                    ^~                                    ^
+    const expected = `---
+stages:
+  - .pre
+  - test
+  - .post
+test_job:
+  needs:
+    - job: build
+      artifacts: true
+      optional: false
+  rules:
+    - if: $RUN_MANUAL
+      when: manual
+  script:
+    - echo '["test","array"]'
+build:
+  script:
+    - ls`;
+
+    expect(writeStreams.stdoutLines[0]).toEqual(expected);
+});
\ No newline at end of file
